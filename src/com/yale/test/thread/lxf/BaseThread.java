package com.yale.test.thread.lxf;

/*
 * 多线程是Java最基本的一种并发模型，本章我们将详细介绍Java多线程编程。
 * 现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务，例如：
 * CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。
 * 例如，假设我们有语文、数学、英语3门作业要做，每个作业需要30分钟。我们把这3门作业看成是3个任务，可以做1分钟语文作业，再做1分钟数学作业，再做1分钟英语作业：
 * 这样轮流做下去，在某些人眼里看来，做作业的速度就非常快，看上去就像同时在做3门作业一样
 * 类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。
 * 即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。
 * 进程
 * 在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。
 * 某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。
 * 进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。
 *                      ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
 * 操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。
 * 因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：
 * 多进程模式（每个进程只有一个线程）：
 *  ┌──────────┐ ┌──────────┐ ┌──────────┐
	│Process   │ │Process   │ │Process   │
	│┌────────┐│ │┌────────┐│ │┌────────┐│
	││ Thread ││ ││ Thread ││ ││ Thread ││
	│└────────┘│ │└────────┘│ │└────────┘│
	└──────────┘ └──────────┘ └──────────┘
	多线程模式（一个进程有多个线程）：
	┌────────────────────┐
	│Process             │
	│┌────────┐┌────────┐│
	││ Thread ││ Thread ││
	│└────────┘└────────┘│
	│┌────────┐┌────────┐│
	││ Thread ││ Thread ││
	│└────────┘└────────┘│
	└────────────────────┘
	多进程＋多线程模式（复杂度最高）：
	┌──────────┐┌──────────┐┌──────────┐
	│Process   ││Process   ││Process   │
	│┌────────┐││┌────────┐││┌────────┐│
	││ Thread ││││ Thread ││││ Thread ││
	│└────────┘││└────────┘││└────────┘│
	│┌────────┐││┌────────┐││┌────────┐│
	││ Thread ││││ Thread ││││ Thread ││
	│└────────┘││└────────┘││└────────┘│
	└──────────┘└──────────┘└──────────┘
 *	进程 vs 线程
 * 进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。
 * 具体采用哪种方式，要考虑到进程和线程的特点。
 * 和多线程相比，多进程的缺点在于：
 * 创建进程比创建线程开销大，尤其是在Windows系统上；
 * 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。
 * 而多进程的优点在于：
 * 多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。
 * 多线程
 * Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。
 * 因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。
 * 和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。
 * Java多线程编程的特点又在于：
 * 多线程模型是Java程序最基本的并发模型；
 * 后续读写网络、数据库、Web开发等都依赖Java多线程模型。
 * 因此，必须掌握Java多线程编程才能继续深入学习其他内容。
 * Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，我们又可以启动其他线程。
 * 要创建一个新线程非常容易，我们需要实例化一个Thread实例，然后调用它的start()方法：
 * 必须调用Thread实例的start()方法才能启动新线程，如果我们查看Thread类的源代码，会看到start()方法内部调用了一个private native void start0()方法，
 * native修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。
 * 线程的优先级,可以对线程设定优先级，设定优先级的方法是：Thread.setPriority(int n) // 1~10, 默认值5
 * 优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。
 * 一个线程对象只能调用一次start()方法；
 * 线程调度由操作系统决定，程序本身无法决定调度顺序；
 * Thread.sleep()可以把当前线程暂停一段时间。
 * 问:线程创建可以实现Callable接口并返回结果，廖老师没有讲这个，是由什么原因吗
 * 廖雪峰反问:你在哪听说可以用Callable创建线程的？
 * 答:菜鸟教程
 * 廖雪峰答:截止到JDK14，Thread一共提供了9个构造方法，没有一个是Callable：
 * https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.html
 * 如果你说的是Callable变成Runnable，那个是Adaptor模式，往后看：
 * https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489
 * 跟Thread本身的构造方法无关
 * 懂了，谢谢廖老师。
 * 实现了Runnable接口的FutureTask作为转换器，在run()方法中调用Callable的call()方法，本质上仍然是实现了Runnable接口。
 * 线程的状态
 * 在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法。一旦run()方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：
 *   New：新创建的线程，尚未执行；
 *   Runnable：运行中的线程，正在执行run()方法的Java代码；
 *   Blocked：运行中的线程，因为某些操作被阻塞而挂起；
 *   Waiting：运行中的线程，因为某些操作在等待中；
 *   Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
 *   Terminated：线程已终止，因为run()方法执行完毕。
 *   用一个状态转移图表示如下：
 *           ┌─────────────┐
	         │     New     │
	         └─────────────┘
	                │
	                ▼
	┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
	 ┌─────────────┐ ┌─────────────┐
	││  Runnable   │ │   Blocked   ││
	 └─────────────┘ └─────────────┘
	│┌─────────────┐ ┌─────────────┐│
	 │   Waiting   │ │Timed Waiting│
	│└─────────────┘ └─────────────┘│
	 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
	                │
	                ▼
	         ┌─────────────┐
	         │ Terminated  │
	         └─────────────┘
 * 当线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。
 * 线程终止的原因有：
 * 线程正常终止：run()方法执行到return语句返回；
 * 线程意外终止：run()方法因为未捕获的异常导致线程终止；
 * 对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。
 * 一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：
 * 线程的状态只有这几种，并且被定义在State中：如果还有其他状态，那就是JDK升级了
 * https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.State.html
 * 
 * 一个CPU任意时刻当然只能运行一个线程，其他可以运行的线程都在等待操作系统分配CPU
 * 你把这种状态的线程和等待锁的状态区分清楚就可以了，判断一个RUNNABLE状态的线程是不是正在被CPU执行其实没啥意义，因为高级应用程序并不能控制底层。
 * 问:什么是线程优先级？我听说它可以用来控制调度。
 * 答:线程的优先级可以对调度器产生影响,但也是没有绝对的保证。优先权的级别会告诉调度器某个线程的重要性,低优先级的线程也许会把机会让给高优先级的线程,
 * 也许.....建议你可以用优先级来影响执行性能,但绝不能依靠优先级来维持程序的正确性。
 * 《Head Fitst Java》
 */
public class BaseThread {
	public static void main(String[] args) {

	}
}
