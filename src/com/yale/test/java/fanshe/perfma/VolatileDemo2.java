package com.yale.test.java.fanshe.perfma;

/**
 * 在早期的 CPU 中，是通过在总线上加 LOCK# 锁的形式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，
 * 也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。
 * 所以就出现了缓存一致性协议。最出名的就是 Intel 的 MESI 协议，MESI 协议（这类协议有MSI、MESI、MOSI及Dragon Protocol等）保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，
 * 会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
 * 
 * 看了那么多文章,其实我发现volatile只有俩个大的作用,第一个是禁止指令重排序。第二个就是可见性。什么是指令重排序？看下面的代码
 * int i = 0;              
 * boolean flag = false;
 * i = 1;                //语句1  
 * flag = true;          //语句2
 * 其实真正运行的时候,语句1和语句2的顺序实际是会发生变化的,取决于指令怎么重排序了。
 * 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
 * 比如上面的代码中，语句 1 和语句 2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句 2 先执行而语句 1 后执行。
 * 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：
 * int a = 10;    //语句1
 * int r = 2;    //语句2
 * a = a + 3;    //语句3
 * r = a*a;     //语句4
 * 这段代码有4个语句，那么可能的一个执行顺序是：
 * 语句2  语句1  语句3  语句4
 * 那么可不可能是这个执行顺序呢：语句2  语句1  语句4  语句3
 * 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令 Instruction 2  必须用到Instruction 1的结果，那么处理器会保证 Instruction 1会在 Instruction 2 之前执行。
 * 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：
 * //线程1:
 * context = loadContext();   //语句1
 * inited = true;             //语句2
 *	//线程2:
 *	while(!inited ){
 *	  sleep()
 *	}
 *	doSomethingwithconfig(context);
 * 上面代码中，由于语句 1 和语句 2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程 1 执行过程中先执行语句 2，而此时线程 2 会以为初始化工作已经完成，那么就会跳出 while 循环，去执行doSomethingwithconfig(context)方法，而此时 context 并没有被初始化，就会导致程序出错。
 * 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
 * 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
 * x、y为非volatile变量
	flag为volatile变量
	x = 2;        //语句1
	y = 0;        //语句2
	flag = true;  //语句3
	x = 4;         //语句4
	y = -1;       //语句5
 * 由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句 3 放到语句 1、语句 2 前面，也不会讲语句 3 放到语句 4、语句 5 后面。但是要注意语句 1 和语句 2 的顺序、语句 4 和语句 5 的顺序是不作任何保证的。
 * 并且 volatile 关键字能保证，执行到语句 3 时，语句 1 和语句 2 必定是执行完毕了的，且语句 1 和语句 2 的执行结果对语句 3、语句 4、语句 5 是可见的。
 * //线程1:
	context = loadContext();   //语句1
	inited = true;             //语句2
	 
	//线程2:
	while(!inited ){
	  sleep()
	}
	doSomethingwithconfig(context);
 * 前面举这个例子的时候，提到有可能语句 2 会在语句 1 之前执行，那么久可能导致 context 还没被初始化，而线程 2 中就使用未初始化的 context 去进行操作，导致程序出错。
 * 这里如果用 volatile 关键字对 inited 变量进行修饰，就不会出现这种问题了，因为当执行到语句 2 时，必定能保证 context 已经初始化完毕。
 * 请分析以下哪些操作是原子性操作：
 * x = 10;         //语句1
 * y = x;         //语句2
 * x++;           //语句3
 * x = x + 1;     //语句4
 * 咋一看，有些朋友可能会说上面的 4 个语句中的操作都是原子性操作。其实只有语句 1 是原子性操作，其他三个语句都不是原子性操作。
 * java中 只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
 * https://mp.weixin.qq.com/s/x78EZQ0E0fgKSwGdK5vtwg
 * https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html
 * Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，
 * 线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。
 * 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。
 * 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：
 * lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
 *  unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
 *  read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
 *  load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
 *  use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
 *  assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
 *  store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
 *  write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
 * 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：
 * 不允许read和load、store和write操作之一单独出现
 * 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
 * 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
 * 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
 * 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
 * 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
 * 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
 * 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。
 * 为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：
 * 
 * https://mp.weixin.qq.com/s/neDCzdVoXiger9D1hXBcag
 * 关于volatile的知识看再多文章也不如看一下图灵学院诸葛老师的视频,看视频讲解的非常清晰易懂。
 */
public class VolatileDemo2 {
	public volatile int inc = 0;
	
	public void increase(){
		inc++;
	}
	
	public static void main(String[] args) {
		final VolatileDemo2 vd = new VolatileDemo2();
		for(int i=0;i<10;i++){
			new Thread(){
				public void run(){
					for(int j=0;j<1000;j++){
						vd.increase();
					}
				}
			}.start();
		}
		
		/*
		 * Thread.activeCount(),返回当前线程组里面的线程数
		 * Thread.activeCount()最终调用的还是ThreadGroup这个类的方法
		 * currentThread().getThreadGroup().activeCount()
		 */
		while(Thread.activeCount()>1){//activeCount这个方法只用于调试,因为值有可能不准,自己看activeCount方法的注释。
			Thread.yield();//yield:yield是Thread类中的方法,意思向调度程序提示当前线程愿意让步当前使用的处理器。 调度程序可以随意忽略此提示。会释放锁,看源码注释就知道了
		}
		
		/*
		 * 大家想一下这段程序的输出结果是多少？也许有些朋友认为是 10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于 10000 的数字。
		 */
		System.out.print("最终结果是什么?" + vd.inc);
	}
}
