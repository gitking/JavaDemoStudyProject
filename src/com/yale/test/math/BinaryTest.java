package com.yale.test.math;

import java.lang.reflect.Modifier;

/**
 * https://www.imooc.com/video/21177
 * 慕课网的 舞马 老师 二进制与Java中的基本数据类型 课程
 * 【【计算机科学速成课】[40集全/精校] - Crash Course Computer Science-哔哩哔哩】https://b23.tv/ZlioyU
 * 二进制的计算规则
 * 1 * 1 = 1 
 * 1 * 0 = 0
 * 0 * 1 = 0
 * 0 * 0 = 0
 * 二进制的缺点:位数太长,可读性差
 * 二进制与八，十六进制之间的进制转换非常直接(每3位二进制数可以转换为1位八进制数，每4位二进制数可以转换为1位十六进制数).
 * java中可以直接声明二(0b开头的是二进制),八(0开头的是八进制),十(默认就是十进制),十六进制(0x开头的是十六进制)
 * 八进制和十六进制的优点：既缩短了二进制数,又保持了二进制的表达特点
 * 简化了二进制与十进制之间的转换。
 * 特别注意：同一个数的不同进制的表示是完全相同的，例如15=0xf＝0b1111。
 * 十进制数字:261代表的意思是有2个100+6个10+1个1=200+60+1=261,每个数字是下标都是后面一个数字下标的10倍。
 * 那么二进制呢？也是一样的:100000101( 1        0       0      0      0    0     1    0   1 
 * 							  1个256    0个128   0个64  0个32   0个16 0个8  1个4  0个2 1个1   	)
 * 			  所以二进制:100000101  = 256 + 0    + 0    + 0     +  0  + 0  + 4   + 0  + 1 = 261
 * 【【计算机科学速成课】[40集全/精校] - Crash Course Computer Science-哔哩哔哩】https://b23.tv/ZlioyU,下面是B站上面第6集的内容.
 * Arithmetic(算术)Logic(逻辑)Unit(单元)=ALU算术单元()
 * CARRY进位,HALF ADDER半加器,FULL ADDER全加器,OVERFLOW溢出,GATE逻辑门,ALU算术单元,LOGIC UNIT逻辑单元,OPERATION CODE(操作码4BITS)
 * 你想让CPU干活,你会给CPU几个输入和一个操作码,比如让CPU算1+1等于几？俩个1就是输入,+就是操作码,操作代码告诉ALU执行什么操作.
 * ALU还会输出一堆标志(Flag),标志占1位(bit),代表特定状态,FLAGS(标志有以下几个):1.OVERFLOW(溢出)2.ZERO(结果是否为0)3.NEGATIVE(结果是否为负数)
 * 不同的算法对应不同的标志位,比如加法的输出标志就会用到OVERFLOW(溢出)这个标志。高级ALU有更多标志.但这3个标志是普遍用的.
 * 比如做减法的时候:如果想知道俩个数字是否相等,看ZERO标志位就知道了,想知道第一个数是否小于第二个数看NEGATIVE标志位就行了
 * 电子移动的很快,如今的CPU每秒可以进行几十亿次运算,所以会造成影响,所以现代计算机用的加法电路有点不同,叫CARRY LOOK AHEAD ADDER(超前进位加法器),这更快,
 * 做的事情是一样的。把二进制数相加.
 * ALU的算术单元,也能做一些其他数学运算,一般支持这个8个操作
 * 1.加法 ADD: A and B are summed
 * 2.带进位的加法 ADD with CARRY: A and B a Carry-In bit are all summed
 * 3.减法 SUBTRACT: B is subtracted from A(or vice-versa)
 * 4.带借位的减法 SUBTRACT with BORROW: B is subtracted from A(or vice-versa) with borrow (carry-in)
 * 5. NEGATE: A is subtracted from zero,flippiing its sign (from - to +, or + to -)
 * 6.增量(+1) INCREMENT: Add 1 to A
 * 7.减量(-1) DECREMENT: Subtract 1 from A
 * 8.数字无改变通过 PASS THROUGH: All bits of A are passed
 * 注意ALU算术单元不支持乘法和除法,因为乘法可以通过多次加法来实现,比如12*5,把12加5次就可以了.一般只有高级处理器才支持乘法和除法,比如手机和笔记本的处理器。
 * 英特尔的第一款CPU用了大概70个gate逻辑门,不能执行乘除.
 * 结算内存使用OR 和 AND 和 NOT来存储数据:AND-OR LATCH->ANT-OR锁存器。GATED LATCH门锁
 * GATED LATCH门锁(锁存器),内存有一条线叫WRITE ENABLE允许写入线,还有一条DATA IN数据输入线,如果要想写入数据,必须将允许写入线通电.一个GATED LATCH门锁只能存一个bit(位)
 * 一组这样的GATED LATCH门锁叫register寄存器,早期电脑用8位寄存器(8个GATED LATCH门锁组成一个寄存器),然后是16位,32位,64位,一个寄存器能存一个数字,这个数值有多少位,叫位宽.
 * 最早的寄存器是把8个GATED LATCH门锁排成一排,然后这个8个门锁都可以存数据,所以一个最早的时候一个寄存器就可以存8位数据.一排存放的缺点是需要的线路太多了.所以后来寄存器为了减少线路换成矩阵排列门锁了.
 * 矩阵排列的寄存器,一次一个寄存器只能启用一个锁存器,所以矩阵排列的寄存器,一个寄存器一次只能存放一位数据.但是一个寄存器可以多次存放数据.
 * 我们排列一个16x16的矩阵,这样一个寄存器就有16x16=256个门锁,为啥是16x16呢?因为寻址的关系,要想具体的定位到矩阵里面的某一个门锁,需要提供矩阵的行和列的值,
 * 比如:第16列,第16行.行和列的值都需要转换成二进制,4个bit能表示的最大值是1111=15(0-15)总共16个数字,一个内存地址8位一个byte字节,刚好可以分成行(4个bit)和列(4个bit)的值.
 * 所以最早的寄存器的矩阵排列就设计成16x16的矩阵了,为了寻址方便.8个矩阵寄存器放一排,一行8个,一次可以存放一个8个位一个字节.这个字节有一个唯一的内存地址,每8个bit一个字节有一个唯一的内存地址.
 * 这里要注意,8个寄存器并排放组成一个RAM(内存),正常来说一个寄存器寻址都需要8bit一个字节的内存地址,8个寄存器放一排,要想往这个8个寄存器里面都各存一个bit的数据,需要8个字节的内存地址,
 * 但是为了存取方便,这里给这个8个寄存器都传一个一模一样的地址,比如要存数据的时候8个寄存器都往同一个位置存放数据,比如8个寄存器刚开始都往第一行第一列存数据,然后依次类推.然后把这8个寄存器看成一个整体,
 * 往这个整体里面写一个字节8位(00001111)的数据的时候,只需要传一个内存地址就行了.只不过8个寄存器每一个寄存器存的值是不一样的,但是存的位置是一样的.所以把这8个寄存器当成一个整体来看的话,这个整体总共有16x16=256个内存地址.
 * 所以8个16x16的矩阵寄存器总共有256个唯一的内存地址.
 * 后来的矩阵有128x64,矩阵越大需要的寻址就越大.
 * CPU(Central Processing Unit中央处理单元)负责执行程序,程序由一个个操作组成,这些操作叫"指令Instruction",指示计算机要做什么.
 * 比如加法和减法,CPU会让ALU进行数学运算.寄存器用来存临时存数据和操作数据。
 * OPCDE(Operation code 操作代码)
 * 指令地址寄存器:追踪程序运行到哪里了,存当前指令的内存地址.
 * 指令寄存器:存当前指令
 * 当启动计算机时,所有寄存器从0开始.
 * CPU有自己的寄存器,CPU的寄存器跟RAM内存中间用"地址线","数据线","允许读/写线"进行通信.
 * CPU的第一个阶段叫:"取指令阶段",负责拿到指令。怎么拿指令?答:假如我们在RAM里面芳丽一个程序,记住程序有一个一个指令组成.指令地址寄存器会连接到RAM(内存),因为启动计算机的时候,所有寄存器都是从0开始,指令地址寄存器也是从0开始,
 * 所以这个时候,指令地址寄存器就会去RAM的第0个地址拿到一个指令.拿到指令后会把拿到的指令复制到指令寄存器里.
 * CPU的第二个阶段叫:"DECODE PHASE,解码阶段",上一步拿到指令之后,要弄清楚拿到的是什么指令,才能执行(execute),这就叫解码.假如指令是:00101110,前4位是0010是LOAD_A指令,
 * LOAD_A的意思是把RAM的值放入寄存器A,后4位1110是RAM的地址.所以00101110这个指令的意思就是把1110这个RAM内存地址上面的值,读取到寄存器A里面去.
 * CPU的第三个阶段叫:EXECUTE PHASE执行阶段,CPU就会把RAM地址1110上面存的值,读取到寄存器A里面去.
 * 接下来重复上面的的步骤,读取第二指令,然后解码,然后执行.
 * 加法指令:10000100,这条指令的前四位1000是加法的意思,后面的0100这次指的不是RAM的内存地址了,而是值CPU的寄存器地址,第一个地址01代表寄存器B,第二个地址00代表寄存器A.
 * 这里寄存器的顺序很重要,因为结果会存在第二个寄存器里面(00这个寄存器里面).
 * 
 * 因此10000100这条指令的意思是:把寄存器B的值加到寄存器A里.CPU会让ALU去计算结果,然后把计算结果暂存在CPU自己的一个寄存器里面,然后关闭ALU,然后再把暂存的结果写入到寄存器A里面.
 * 然后CPU继续读取下一个指令:01001101,解码后知道0100是STORE_A指令,STORE_A的意思是把寄存器A的值放入1101这个RAM地址里面去.
 * 但是是由谁来指挥CPU干活呢,多久干一次活呢?实际上有一个时钟,这个时钟以精确的间隔触发电信号.控制单元会用这个信号,指挥CPU干活.这个间隔空控制CPU的节奏.
 * 节奏不能太快,因为就算是电也需要时间来传输,CPU“取指令->解码->执行”的速度叫“时钟速度CLOCK SPEED”,单位是赫兹(Herta),赫兹是用来表示频率的单位.
 * 1赫兹代表1秒一个周期,1秒一次就是1赫兹,1兆赫兹是1秒1百万个时钟周期
 * 你可能听过有人会把计算机超频,意思就是修改时钟速度,加快CPU的速度,芯片制造商经常给CPU留一点余地,可以接受一点超频.但超频太多会让CPU过热,或者产生乱码,因为信号跟不上时钟.
 * 但其实还有降频:降频可以省电,省电对手机和笔记本超级有用.为了省电,很多现代处理器可以按需求加快或减慢时钟速度.这叫动态调整频率.
 * RISC-V开源指令集,你完全可以用FPGA写一个自己的CPU,这句话来自B站上面的弹幕.
 * CPU是一款硬件,可以被软件控制,所以CPU是可编程的.
 * 
 * CPU指令:
 * 1.JUMP 跳转,JUMP在底层的实现方式是把指令后4位代表的内存地址的值覆盖掉"指令地址寄存器"里的值,
 * 2.特别版的JUMP叫JUMP_NEGATIVE,它只在ALU的负数标志为真时,进行JUMP.这其实叫条件跳转,还有其他类型的条件跳转,比如JUMP IF EQUAL(如果相等),JUMP IF GREATER(如果更大)
 * 3.HALT停止指令,因为计算机还需要知道什么时候该停下来.
 * 
 * 还有一点要知道:指令和数据都是存在同一个内存里的.他们在根本层面毫无区别,都是二进制数.所以HALT很重要,能区分指令和数据.
 * 
 * 指令长度INSTRUCTION LENGTH
 * 可变指令长度VARIABLE LENGTH INSTRUCTIONS
 * 立即值 IMMEDIATE VALUE
 * 1971年,英特尔发布了4004处理器,它支持46个指令,包括JUMP(跳转),ADD(加法),SUB(减法),LOAD(读取)它也用8位的"立即值"来执行JUMP,以表示更多内存地址.
 * 现代CPU,比如英特尔酷睿i7,有上千个指令和指令变种.指令长度从1到15个字节.
 * 
 * 在1940~1950年代,每个操作码分配一个简单的名字,叫"助记符","助记符"后面紧跟数据,形成完整指令,与其用1和0写代码, 程序员可以写"LOAD_A 14"
 * 当然,CPU不知道LOAD_14是什么,CPU不能理解文字,只能理解二进制,所以程序员发明了汇编器Assembler.汇编器读取用"汇编语言"写的程序,然后转成"机器码".她可以读懂文字指令,自动转成二进制指令.
 * 汇编器不用固定跳转地址,而是让你插入可跳转的标签.当程序被传入汇编器,汇编器会自己搞定跳转地址.程序员可以专心编程,不用管底层细节,隐藏不必要细节来做更复杂的工作.又提升了一层抽象.
 * 汇编只是修饰了一下机器码,一般来说,一条汇编指令对应一条机器指令,所以汇编码和底层硬件的连接很紧密.汇编器仍然强迫程序员思考,用什么寄存器和内存地址.如果你突然要一个额外的数,可能要改很多代码.
 * @author dell
 */
public class BinaryTest {  
	public static void main(String[] args) {
		int bin = 0b1100010;//0b开头的是二进制,英文字母b x是不区分大小写的,jvm底层存储的其实还是二进制
		int oct = 0142;//0开头的是八进制
		/**
		 * 每俩位的十六进制数就是8位的二进制,刚好是一个字节,所以Java的class文件叫字节码
		 */
		int hex = 0x62;//0x开头的是十六进制,英文字母b x是不区分大小写的,jvm底层存储的其实还是二进制
		int dec = 98;
		System.out.println("2:" + bin);
		System.out.println("8:" + oct);
		System.out.println("16:" + hex);
		System.out.println("10:" + dec);
		
		System.out.println("**********************************************");
		System.out.println();
		
		System.out.println("java中的进制转换方法:");
		System.out.println("转换二进制显示:" + Integer.toBinaryString(dec));
		long lNum = 9999999L;//数字本身就是以二进制形式存储的,如果要在UI界面上看到这个数字的二进制位,所以才转换成字符串来显示.
		System.out.println("Long转换二进制显示:" + Long.toBinaryString(lNum));
		System.out.println("转换为八进制显示:" + Integer.toOctalString(dec));
		System.out.println("转换为十六进制显示:" + Integer.toHexString(dec));
		System.out.println("**********************************************");
		System.out.println();

		System.out.println("自由度更高的转换方法:Integer.toString(int i, int radix)方法:");
		System.out.println("radix参数的可使用范围是2-36,为什么最高是36？因为英文字母是26个,加上10个阿拉伯数字,最高就是36进制了");
		System.out.println("Integer.toString(int i, int radix)方法:转换为二进制显示:" + Integer.toString(dec, 2));
		System.out.println("Integer.toString(int i, int radix)方法:转换为八进制显示:" + Integer.toString(dec, 8));
		System.out.println("Integer.toString(int i, int radix)方法:转换为十六进制显示:" + Integer.toString(dec, 16));

		System.out.println("**********************************************");
		System.out.println();
		
		//将其他进制的数据转换为十进制数据,使用Integer.parseInt(String, int),Integer.valueOf(String, int)来完成,Long也有类似的方法
		System.out.println("将字符串转换为数字:Integer.parseInt(String s, int radix)方法:");
		System.out.println("将字符串转换为数字:Integer.valueOf(String s, int radix)方法:");
		System.out.println("Integer.parseInt将二进制的字符串转换为十进制:" + Integer.parseInt("1100010", 2));
		System.out.println("Integer.parseInt将八进制的字符串转换为十进制:" + Integer.parseInt("142", 8));
		System.out.println("Integer.parseInt将十六进制的字符串转换为十进制:" + Integer.parseInt("62", 16));
		
		System.out.println("valueOf方法里面用的就是parseInt" + Integer.valueOf("1100010", 2)); 
		System.out.println("*************************************");
		System.out.println("什么是位运算:位运算就是直接对整数在内存中的二进制位进行操作,位运算实际上是对二进制进行的操作,而不是数学运算,位运算分为俩种:逻辑操作和位移操作");

		/*
		 * 数字与byte[]之间的转换是什么意思呢?大家都知道,在java语言中,int是由4个字节(byte)组成的,在网络上发送数据的时候,都是通过byte流来处理的.
		 * 所以会发送4个byte的内容,4个byte会由高到底顺序排列发送,接收方反方向解析,在java中可以基于DataOutputStream,DataInputStream的writeInt(int)
		 * 和readInt()来得到正确的数据.
		 * 如果使用了通道相关的技术,ByteBuffer则由相关的API来实现,如果其他语言提供的API希望将这些byte位交互位置(如果要求低位先发送),那么你就要自己来处理了.
		 * 而处理方式就可以参考DataXXXStream的处理方式.DataXXXStream还有一个readFull()方法,这个方法要求读满一个缓冲区后才返回数据,它会在内部循环处理.
		 * DataXXXStream中不仅仅有对int类型的处理,还有对boolean,byte,unsignedbyte,short,unsigned short,char, int, long,float,unsigned float,double,
		 * UTF的处理.
		 * 在ByteBuffer的实现类中也提供了各种数据类型的put,get操作,内部也是通过byte转换来完成的.
		 * 在java.io.Bits,java.nio.Bits类中也有大量的数字与byte[]的转换操作(这个俩个类我们的程序无法直接使用,但是可以看源码),可以参考他们的代码来实现自己的特定需求.
		 */
		System.out.println("比特(bit):信息量的最小单位,单位是小写b,bit只能表示二进制的1或者0");
		System.out.println("字节(byte):表示信息的最小单位,单位是大写B,1byte=8bit,计算机中所有的数据都是以字节为单位存储的.");
		//【【计算机科学速成课】[40集全/精校] - Crash Course Computer Science-哔哩哔哩】https://b23.tv/ZlioyU
		System.out.println("机器数:将数据的首位设定为符号位:,0为正,1为负,机器数的数值大小受到机器字长的限制,不像你在纸上想写多长的数字就写多长的数字");
		System.out.println("机器数的形式:原码,反码,补码,原码就是加入符号位的就叫原码");
		System.out.println("反码就是二进制数值全部取反了,好像只针对负数这样子");
		System.out.println("补码就是反码的基础上加1得到的结果,好像只针对负数这样子");
		System.out.println("补码计算方式:正数补码=反码=原码,负数补码=反码+1");
		System.out.println("在如今绝大多数的系统和语言当中记录数值都是以补码的方式存放的,为什么要用补码这么不直观的记录方式呢？实际上就是为了简化计算机的计算过程以提高效率,");
		System.out.println("用原码表示正负数,如果负数参与运算,我们就需要先识别他的符号位,然后再进行运算.而用补码就可以省略这一步,补码的符号位是可以直接参与运算的,并且可以得到正确的结果.");
		System.out.println("看个例子:");
		/**
		 * 整数                                      补码
		 * 1 		0000 0001
		 * -1		1111 1111
		 * 5		0000 0101
		 * -5		1111 1011
		 * 负数相加: -1 + -5 = (1111 1111) + (1111 1011)都是补码在参与运算
		 * 				  =  1 1111 1010(注意这里是9位,比一个字节多了一位,)
		 * 				  =  1111 1010 (直接把前面多出的部分删除,保留8位，刚好就是-6)
		 * 				  = -6
		 * 正负相加(实际就是减法): (+1) + (-1) = (0000 0001) + (1111 1111)都是补码在参与运算
		 * 								= (1 0000 0000)
		 * 								= (0000 00000)
		 * 							    = 0
		 * 使用补码就是为了方便实现运算过程,可以将符号位也参与到运算当中
		 */
		System.out.println("位运算分为俩种:逻辑操作和位移操作:");
		System.out.println("逻辑操作就是一下几种: java运算符: &按位与,|按位或,^按位异域,~按位取反");
		//https://www.w3cschool.cn/java/java-bitwise-operators.html,按位操作符作用于其操作数的各个位。Java按位运算符可以应用于整数types: long，int，short，char，byte 
		//>>向右移动 >>>右移零填充  <<向左移动 &=按位AND分配 |=按位OR分配 ^=按位异OR分配 >>=右移赋值 >>>=右移零填充分配  <<=向左移位
		System.out.println("位移操作就是一下几种: java运算符: <<左移, >>右移, >>>无符号右移");
		/*
		 * 移位运算
		         在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下：
		   00000000 0000000 0000000 00000111
		         可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28：
		 */
		int n = 7;       // 00000000 00000000 00000000 00000111 = 7
		int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
		int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
		int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
		int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912,  左移29位时，由于最高位变成1，因此结果变成了负数。
		
		/*
		 * 类似的，对整数28进行右移，结果如下：
		 */
		int nn = 7;       // 00000000 00000000 00000000 00000111 = 7
		int aa = nn >> 1;  // 00000000 00000000 00000000 00000011 = 3
		int bb = nn >> 2;  // 00000000 00000000 00000000 00000001 = 1
		int cc = nn >> 3;  // 00000000 00000000 00000000 00000000 = 0
		/**
		 * 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：
		 * 有符号的右移应该前面是补1，所以这里是不是写错了？
		 * 应该是写错了，查阅了一些资料，而且自己验证了一下，廖老师解释的不通。
		 * 右移前面不是补1，第一位的0或1表示的是正负，使用>>的时候第一位是正负是不会移动的。不论左移还是右移空出来的位置都是补0.
		 * 应该是写错了，试了一下10111000 00000000 00000000 00000000的结果并不是-134217728，11111000 00000000 00000000 00000000的结果才是
		 * https://www.liaoxuefeng.com/wiki/1252599548343744/1255888634635520
		 */
		int nbb = -536870912;
		int abb = nbb >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
		int bbb = nbb >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
		int ccc = nbb >> 28; // 11111111 11111111 11111111 11111110 = -2
		int dcc = nbb >> 29; // 11111111 11111111 11111111 11111111 = -1
		
		/*
		 *还有一种不带符号的右移运算，使用>>>，它的特点是符号位跟着动，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0： 
		 */
		int ndd = -536870912;
		int add = ndd >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
		int bdd = ndd >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
		int cdd = ndd >>> 29; // 00000000 00000000 00000000 00000111 = 7
		int ddd = ndd >>> 31; // 00000000 00000000 00000000 00000001 = 1
		//对byte和short类型进行移位时，会首先转换为int再进行位移。
		//仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。
		
		//对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：
		int i = 167776589; //  00001010 00000000 00010001 01001101
        int nb = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i & nb); // 167776512
        //上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。
        //牛客网练习题https://www.nowcoder.com/questionTerminal/34a597ee15eb4fa2b956f4c595f03218?f=discussion
        //码云 https://gitee.com/
        /*
         * 在Java的计算表达式中，运算优先级从高到低依次是：
		    ()
		    ! ~ ++ --
		    * / %
		    + -
		    << >> >>>
		    &
		    |
		    += -= *= /=
		记不住也没关系，只需要加括号就可以保证运算的优先级正确。
		类型自动提升与强制转型
		在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int：
         */
        //也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short：
        //要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节：因此，强制转型的结果很可能是错的。
        int i1 = 1234567;//整数运算的结果永远是精确的
        short s1 = (short) i1; // -10617
        System.out.println(s1);
        int i2 = 12345678;
        short s2 = (short) i2; // 24910
        System.out.println(s2);
        
        //&可以用来控制范围,比如A&4999,这个操作得到数据将会永远<=4999,类似于A%4999(取余数)永远不可能大于4999一样的道理
        int areaNum = 10;//10的二进制组合是1010,意味着任何数字与10进行&操作后都得不到0001(1),0100(8),0101(9)这三个数字,因为&这个运算符只要碰到0就是会变成0
        //所以使用&来控制范围的时候最好选择二进制位都是1的数字,如1,127,255,511,1023等.注意,二进制的尾数如果是1的话,他就是奇数
        int areaResult = 9999 & areaNum;
		System.out.println("areaResult的结果肯定小于10:" + areaResult);
		//布尔代数中有三个基本操作:~NOT,&AND和|OR,还有一个^XOR
		System.out.println("按位与运算:&(AND),定义:参加运算的俩个数据,按二进制位进行‘于’运算,与运算:俩个数都为 1,则结果为1");//"与运算"（AND）
		System.out.println("&位与运算:1&1 = 1, 1&0 = 0, 0&1 =0, 0&0 = 0 ");
		System.out.println("示例:14&3即0000 1110 & 0000 0011 = 0000 0010 = 整数2,因此14&3=2,特点:①清零特定位②获取特定位");
		System.out.println("注意,二进制的尾数如果是1的话,他就是奇数");
		int xt = 10;//位组合是0000 1010
		int yt = 6;//位组合是0000 0110
		//按位与运算符:&,如果俩个位都是1才会返回1,否则返回0.
		int at = xt & yt; //位组合是0000 0010
		
		/*
		 * 大量判定"是|否"的操作
		 * 如果一个系统中的许多操作都是在判定是与否,为了节约内存不会为每一个是,否的值用一个单独int来存储,因为int会占用4个字节32bit.注意在java中单独定义boolean类型也是占用32bit(4个字节)
		 * 有些同学判断是否的时候会先用Integer.toBinaryString(dec)将int变量转换二进制字符串,然后再取出这个字符串上指定位置的char,再判断这个char是0还是1,这显然有点过分了
		 * 我们可以模仿Java自己类库里面是怎么操作的,例如“java.lang.reflect.Modifier”,它对类型修饰符有各种各样的判定,
		 * 例如:public final static 这样的一长串内容只用一个数字来表达,它是怎么做到的？Java将这些符号进行了固定的规格的编码,这个编码会在生成class文件时存在,JVM运行时也会使用
		 * 是否为public,使用十六进制数据0x00000001表示
		 * 是否为static,使用十六进制数据0x00000008表示,十六进制的8代表二进制的最后4位是1000.
		 * 是否为final,使用十六进制数据0x00000010表示。十六进制的10代表二进制最后5位为10000.
		 * 在Modifier类中大家可以找到private,protected,synchronized,volatile,transient,native,interface,abstract,strict等各种类型的表达数字.
		 * java程序在读取字节码时,读取到一个数字,该数字只需要与对应的编码进行"&"操作,根据结果是否为0即可得到是否具有相应的标志位了,java用一个数字可以表达多个修饰字符串.
		 * 很多时候需要判断它是不是public final static的,这么多类型要一个一个判断好麻烦,这种情况可以打组合拳,用|或运算,比如Modifier类中定义的:
		 * private static final int CONSTRUCTOR_MODIFIERS = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;
		 * 由于这三项内容的二进制并不冲突,所以做或运算就代表三者都成立,当传入参数后,只需要与这个值做"按位与&"运算就能得到结果,
		 * 不过,现在结果不是跟0比较,而是与CONSTRUCTOR_MODIFIERS比较是否一样(因为需要每个二进制位都要对应上,才能证明它的3个特征都成立),所有的二进制都必须匹配上,一个匹配不上都不行
		 * public static boolean isPublicFinalStatic(int mod) {
		 * 		return (mod & PUBLIC_FINAL_STATIC) == PUBLIC_FINAL_STATIC;
		 * }
		 */
		System.out.println("按位或运算:|(OR),定义:参加运算的俩个数据,按二进制位进行‘或’运算,或运算:俩个数有一个为 1,则结果为1");//"或运算"（OR）
		System.out.println("|位或运算:1|1 = 1, 1|0 = 1, 0|1 =1, 0|0 = 0 ");
		System.out.println("示例:14|3即0000 1110 | 0000 0011 = 0000 1111 = 整数15,因此14|3=15,特点:①将特定位设为1");
		//按位或运算符:|,只要其中一个是1就会返回1.
		int ac = xt | yt;//位组合是0000 1110
		
		//大家比较熟悉的逻辑运算，主要是"与运算"（&AND）和"或运算"（|OR），还有一种"异或运算"（XOR），也非常重要。
		//XOR 是 exclusive OR 的缩写。英语的 exclusive 意思是"专有的，独有的"，可以理解为 XOR 是更单纯的 OR 运算。
		//http://www.ruanyifeng.com/blog/2021/01/_xor.html
		/*
		 * XOR 运算有以下的运算定律。由于非常简单，这里就省略证明了。
		 * 1,一个值与自身的运算，总是为 false。x ^ x = 0
		 * 2,一个值与 0 的运算，总是等于其本身。 x ^ 0 = x
		 * 3,可交换性 x ^ y = y ^ x
		 * 4,结合性 x ^ (y ^ z) = (x ^ y) ^ z
		 * 根据上面的这些运算定律，可以得到异或运算的很多重要应用。
		 * 简化计算：多个值的异或运算，可以根据运算定律进行简化。
		 *   a ^ b ^ c ^ a ^ b 
		 * = a ^ a ^ b ^ b ^ c 
		 * = 0 ^ 0 ^ c 
		 * = c
		 * 交换值
		 * 两个变量连续进行三次异或运算，可以互相交换值。
		 * 假设两个变量是x和y，各自的值是a和b。下面就是x和y进行三次异或运算，注释部分是每次运算后两个变量的值。
		 * x = x ^ y // (a ^ b, b)
		 * y = x ^ y // (a ^ b, a ^ b ^ b) => (a ^ b, a)
		 * x = x ^ y // (a ^ b ^ a, a) => (b, a)
		 * 这是两个变量交换值的最快方法，不需要任何额外的空间。
		 * 加密
		 * 异或运算可以用于加密。
		 * 第一步，明文（text）与密钥（key）进行异或运算，可以得到密文（cipherText）。
		 * text ^ key = cipherText
		 * 第二步，密文与密钥再次进行异或运算，就可以还原成明文。
		 * cipherText ^ key = text
		 * 原理很简单，如果明文是 x，密钥是 y，那么 x 连续与 y 进行两次异或运算，得到自身。
		 *   (x ^ y) ^ y
		 * = x ^ (y ^ y)
		 * = x ^ 0
		 * = x
		 * 数据备份
		 * 异或运算可以用于数据备份
		 * 文件 x 和文件 y 进行异或运算，产生一个备份文件 z。
		 * x ^ y = z
		 * 以后，无论是文件 x 或文件 y 损坏，只要不是两个原始文件同时损坏，就能根据另一个文件和备份文件，进行还原。
		 *   x ^ z
		 * = x ^ (x ^ y)
		 * = (x ^ x) ^ y
		 * = 0 ^ y
		 * = y
		 * 上面的例子是 y 损坏，x 和 z 进行异或运算，就能得到 y。
		 * 一道面试题
		 * 一些面试的算法题，也能使用异或运算快速求解。
		 * 请看下面这道题。
		 * 一个数组包含 n-1 个成员，这些成员是 1 到 n 之间的整数，且没有重复，请找出缺少的那个数字。
		 * 最快的解答方法，就是把所有数组成员（A[0] 一直到 A[n-2]）与 1 到 n 的整数全部放在一起，进行异或运算。
		 * A[0] ^ A[1] ^ ... ^ A[n-2] ^ 1 ^ 2 ^ ... ^ n
		 * 贴上 力扣上缺失的数字题目 https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/
		 * 上面这个式子中，每个数组成员都会出现两次，相同的值进行异或运算就会得到 0。只有缺少的那个数字出现一次，所以最后得到的就是这个值。
		 * 你可能想到了，加法也可以解这道题。
		 * 1 + 2 +  ... + n - A[0] - A[1] - ... - A[n-2]
		 * 但是，加法的速度没有异或运算快，而且需要额外的空间。如果数字比较大，还有溢出的可能。
		 * 下面是一道类似的题目，大家可以作为练习。
		 * 一个数组包含 n+1 个成员，这些成员是 1 到 n 之间的整数。只有一个成员出现了两次，其他成员都只出现一次，请找出重复出现的那个数字。
		 */
		System.out.println("按位异或运算:^(XOR),定义:参加运算的俩个数据,按二进制位进行‘异或’运算,异或运算:俩个数不同,则结果为1");//XOR
		System.out.println("^位异或运算:1^1 = 0, 1^0 = 1, 0^1 =1, 0^0 = 0 ");
		System.out.println("示例:14|3即0000 1110 ^ 0000 0011 = 0000 1101 = 整数13,因此14^3=13,特点:①与自身异或得0 ②与同一个数连续异或得自身");
		//按位异或运算符:^,位相同时返回0,否则返回1
		int aca = xt ^ yt;//位组合是0000 1100
		int t1 = 999;
		int t2 = 999;
		int zero = t1 ^ t2;
		System.out.println("俩个相同的数字^异域的结果应该是0:[" + zero + "]");
		
		long numL = 98989898989L;
		long num = 0;
		long res = numL ^ num;
		System.out.println("一个值与 0 异或的运算，总是等于其本身。x ^ 0 = x结果应该是numL:[" + res + "]");
		
		System.out.println("按位取反运算:~NOT,定义:对一个二进制数按位取反,0变1,1变0");//~NOT
		System.out.println("~取反运算:~1 = 0, ~0 = 1 ");
		System.out.println("示例:~14即~0000 1110 得 1111 0001 = 整数-15,因此~14=-15,这里再次重申计算机当中整数都是以补码的方式存放的");
		//~按位非运算符:~,这个运算符会将primitive主数据类型的字节组合值取反
		int x = 10;//位组合是00001010
		x = ~x;//位组合是11110101
		
		/*
		 * 移位运算符
		 * 此运算符取用单一primitive主数据类型并向某个方向执行移位,如果你的二进制运算技巧够好的话,你就会发现左移的效果与乘以2是一样的,而右移跟除以2一样。
		 * 以下将全世界最短的负数表示成补码,整数最左方的字节称为符号位.Java中的负整数此位永远是1,正数此位永远是0,Java使用补码来存储负值,
		 * 改变正负号时要把位取反然后加1.
		 * Java左移运算符:左移位算子，<<移位所有位中的一个值到左边一个指定的数字的时间。它有这种一般形式:value << num
		 * 以下代码移位字节类型变量。
		 */
		byte wcaz = 64, wcazb;
		int wci;
		wci = a << 2;
		wcazb = (byte)(a<<2);
		System.out.println("Original value of a: " + wcaz);
	    System.out.println("i and b: " + wci + " " + wcazb);
	    //每个左移具有使原始值加倍的效果。以下程序说明了这一点:
	    int w3cnum = 0xFFFFFFF;
	    for (int w3cfi = 0; w3cfi < 4; w3cfi++) {
	      w3cnum = w3cnum << 1;
	      System.out.println(w3cnum);
	    }
	    
		int yy = -11;//位组合是1111 0101
		System.out.println("<<左位移运算:<<,定义:将一个二进制数向左移动对应的位数,而这个移动是不包括符号位的");
		System.out.println("规则:符号位不变,右侧低位补0,左侧高位舍弃 ");
		System.out.println("示例:14<<1 即0000 1110 << 1 得 0001 1100 = 整数28,因此14<<1=28,");
		System.out.println("<<左位移的特点就是相当于乘以这个数的2的位移次方:m<<n = m x 2的n次方(在最高位不为1的情况下),");
		//左移运算符:<<,与>>>一样,但方向相反,右方补0,正负号可能改变
		int zy = yy << 2; //位组合是1101 0100
		
		System.out.println(">>右位移运算:>>,定义:将一个二进制数向右移动对应的位数,而这个移动是不包括符号位的");
		System.out.println("规则:符号位不变,右侧低位舍弃,左侧高位正数补0,负数补1 ");
		System.out.println("示例:14>>1 即0000 1110 >> 1 得 0000 0111 = 整数7,因此14>>1=7,");
		System.out.println("示例:-14>>2 即1111 0010 >> 2 得 1111 1100 = 整数-4,因此-14>>2=-4,");
		System.out.println(">>右位移的特点就是相当于除以这个数的2的位移次方:m<<n = m ÷ 2的n次方(低位为1时,精度会丢失,并非为完全整除的情况),");
		//右移运算符:>>,以指定量右移字节组合,左方补0,正负号不变。
		int yxy = yy >> 2;//位组合是1111 1101
		
		//Java右移运算符,右移位运算符>> 将值中的所有位向右移a指定次数。其一般形式如下所示:value >> num,num 指定要向右移位的位置数。以下代码段将值 32 向右移两个位置:
		int w3cy = 32;
		w3cy = w3cy >> 2;
		System.out.println("w3cy is " + w3cy);
	
		System.out.println(">>>无符号右位移运算:>>>,无符号右位移是包括了符号位的,正数无符号位移操作没有什么区别,主要是在负数");
		System.out.println("规则:右侧低位舍弃,左侧高位补0 ");
		System.out.println("示例:-14>>>2 即1111 0010 >>> 2  得 0011 1100 = 整数60,因此-14>>>2=60,");
		System.out.println("这里要说明:数据规定存储的不同字节,负数位移得到的结果也是不同的,不同位数,负数的结果不同");
		System.out.println("示例:这次用俩个字节来存储-14得的结果就大不相同,-14>>>2 即1111 1111 1111 0010 >>> 2 得 0011 1111 1111 1100= 整数16380,");
		//无符号右移运算符:>>>,与>>一样,但第一个位也会补0,正负号可能会改变
		int wy = yy >>> 2; //位组合是0011 1101
		//Java无符号右移,Java无符号，右移运算符，>>> ，始终将零转移到高阶位。其一般形式如下所示:value >>> num,num 指定要向右移位的位置数。以下代码显示如何使用无符号右移。
		int w3cwy = -1;
		w3cwy = w3cwy >>> 24;
		System.out.println("w3cwy is " + w3cwy);

		System.out.println("无符号右位移只是在操作的时候不去考虑符号位,而在最终结果的识别方面,它还是以补码的方式存储,也是有符号位的,这一点一定要注意");
		
		System.out.println("java中的byte(1字节),shor(2字节),int(字节),long(8字节),java中的整数类型都使用二进制的补码存储");
		
		System.out.println("大端模式与小端模式,多字节数据的俩种顺序:大端:高位字节放在低地址,低位字节放在高地址.小端:低位字节放在低地址,高位字节放在高地址.");
		System.out.println("java语言中默认使用的是大端模式");
		
		//https://www.w3cschool.cn/java/java-bitwise-operators.html,按位操作符作用于其操作数的各个位。Java按位运算符可以应用于整数types: long，int，short，char，byte 
		//>>向右移动 >>>右移零填充  <<向左移动 &=按位AND分配 |=按位OR分配 ^=按位异OR分配 >>=右移赋值 >>>=右移零填充分配  <<=向左移位
		//按位运算符分配将赋值与按位运算组合。以下两个语句是等效的:a = a >> 4;  a >>= 4;  以下两个语句是等效的:a = a | b;  a |= b;
		//以下程序演示了按位运算符分配:
		int w3ca = 1;
		int w3cb = 2;
		int w3cc = 3;
		w3ca|=2;
		w3cb>>=2;
		w3cc<<=2;
		w3ca^=w3cc;
		System.out.println("w3ca = " + w3ca);
	    System.out.println("w3cb = " + w3cb);
	    System.out.println("w3cc = " + w3cc);
	    
	    /**
	     * 求女票上微博问:为什么?
	     * byte的-1的二进制表示是11111111
	     * 按照 第一位 是符号位 11111111 不是应该表示 - 127 么？？？
	     * 廖雪峰答:负数在计算机中用补码表示，计算方法是除符号位外取反+1，-1的原码是10000001，取反=111111110，再+1=11111111
	     * 之所以用补码不是原码是因为补码可以把减法转换为加法
	     * 
	     * 自动装拆箱仅发生在编译的时候，为啥还影响运行效率
	     * 廖雪峰答:
	     * Integer n = 1000;
	     * 编译后执行的代码：
	     * Integer n = Integer.valueOf(1000);
	     * 这个方法运行期肯定要执行
	     * https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400
	     * 
	     * 位运算和位移运算。
	     * 位运算和位移运算符是低层运算符，是处理组成整数的单个位。除非处理低层操所（例如网络编程）。若想学会这个，必须先理解二进制数以及用于表示负整数的二进制的补码方式。位运算和位移运算不能操作浮点数，布尔值或者数组或者对象。只能操作int和long类型的数字。
	     * 如果位移运算符左边的操作数是long类型，结果就是long类型。否则结果就是int类型。
	     * 如果位运算符的操作数中有一个是long类型结果就是long类型。否则，结果都是int类型。
	     * 已上内容大部分是从书《Java技术手册(第六册)》中摘抄过来的,《Java技术手册(第六册)》[美]David Flanagan [中]安道译
	     * https://blog.csdn.net/u010477645/article/details/51713375
	     */
	}
}
