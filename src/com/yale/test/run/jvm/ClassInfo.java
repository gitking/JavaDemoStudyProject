package com.yale.test.run.jvm;

/*
 * https://mp.weixin.qq.com/s/CH9D-E7fxuu462Q2S3t0AA
 * https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html
 * https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html
 * 编译后生成.class文件，打开后是一堆十六进制数，JVM对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？
 * JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如图 class字节码结构.png 所示。
 * 1、魔数（Magic Number）所有的.class文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE。
 * 魔数放在文件开头，JVM可以根据文件的开头来判断这个文件是否可能是一个.class文件，如果是，才会继续进行之后的操作。
 * 2、 版本号，版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。
 * class字节码结构.png中版本号为“00 00 00 34”，次版本号转化为十进制为0，主版本号转化为十进制为52，在Oracle官网中查询序号52对应的主版本号为1.8，
 * 所以编译该文件的Java版本号为1.8.0。
 * 3、常量池（Constant Pool）紧接着主版本号之后的字节为常量池入口。常量池中存储两类常量：字面量与符号引用。字面量为代码中声明为Final的常量值，
 * 符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。
 * 常量池整体上分为两部分：常量池计数器以及常量池数据区，如下图 常量池的结构.png 所示。
 * 常量池计数器（constant_pool_count）：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。
 * 图2中示例代码的字节码前10个字节如下图5所示，将十六进制的24转化为十进制值为36，排除掉下标“0”，也就是说，这个类文件中共有35个常量。
 * 常量池数据区：数据区是由（constant_pool_count-1）个cp_info结构组成，一个cp_info结构对应一个常量。在字节码中共有14种类型的cp_info（如下图 各类型的cp_info.jpg），每种类型的结构都是固定的。
 * 具体以CONSTANT_utf8_info为例，它的结构如下图7左侧所示。首先一个字节“tag”，它的值取自上图6中对应项的Tag，由于它的类型是utf8_info，
 * 所以值为“01”。接下来两个字节标识该字符串的长度Length，然后Length个字节为这个字符串具体的值。从图2中的字节码摘取一个cp_info结构，
 * 如下图7右侧所示。将它翻译过来后，其含义为：该常量类型为utf8字符串，长度为一字节，数据为“a”。
 * （4） 访问标志
 * 		常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。
 * 		JVM规范规定了如下图9的访问标志（Access_Flag）。需要注意的是，JVM并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，
 * 		比如某个类的修饰符为Public Final，则对应的访问修饰符的值为ACC_PUBLIC | ACC_FINAL，即0x0001 | 0x0010=0x0011。
 * （5） 当前类名
 * 		访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。
 * （6） 父类名称
 * 		当前类名后的两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。
 * （7） 接口信息
 * 		父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。
 * （8） 字段表
 * 		字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。字段表也分为两部分，
 * 		第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info。字段表结构如图  字段表结构.jpg所示：
 * 		以图2中字节码的字段表为例，如下图11所示。其中字段的访问标志查图9，0002对应为Private。通过索引下标在图8中常量池分别得到字段名为“a”，
 * 		描述符为“I”（代表int）。综上，就可以唯一确定出一个类中声明的变量private int a。
 * （9）方法表
 * 		字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数；第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，
 * 		如下图所示：
 * 		方法的权限修饰符依然可以通过图 访问标志.jpg 的值查询得到，方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到。而“方法的属性”这一部分较
 * 		为复杂，直接借助javap -verbose将其反编译为人可以读懂的信息进行解读，如图13所示。可以看到属性中包括以下三个部分：
 * 			1)Code区”：源代码对应的JVM指令操作码，在进行字节码增强时重点操作的就是“Code区”这一部分。
			2)“LineNumberTable”：行号表，将Code区的操作码和源代码中的行号对应，Debug时会起到作用（源代码走一行，需要走多少个JVM指令操作码）。
			3)“LocalVariableTable”：本地变量表，包含This和局部变量，之所以可以在每一个方法内部都可以调用This，是因为JVM将This作为
			每一个方法的第一个参数隐式进行传入。当然，这是针对非Static方法而言。
	（10）附加属性表
		字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。
 * 在 操作码_助记符.png 图中,Code区的红色编号0～17，就是.java中的方法源代码编译后让JVM真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，
 * 十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看Oracle官方文档(https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html)进行了解，在需要用到时进行查阅即可。
 * 比如上图中第一个助记符为iconst_2，对应到图2中的字节码为0x05，用处是将int值2压入操作数栈中。以此类推，对0~17的助记符理解后，就是完整的add()方法的实现。
 * 1.4 操作数栈和字节码
 * 		JVM的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，
 * 		基于栈的实现需要更多指令才能完成（因为栈只是一个FILO结构，需要频繁压栈出栈）。
 * 		另外，由于栈是在内存实现的，而寄存器是在CPU的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。
 * 2. 字节码增强
 * 		ASM
 */
public class ClassInfo {
	/*
	 * 相信所有的java程序员在编写java程序的时,大部分操作都是申请对象和操作对象,而对象实例的空间大部分存储在Java的堆(Heap)当中,而java的栈当中存储什么呢?
	 * java的栈更多是通过Java与OS一起管理的一块区域,写过C/C++程序的人应该知道,如果不是通过malloc,realloc,new等关键字申请的内存空间,那么作用域结束时空间自然释放,
	 * 因为这部分的回收操作时由OS来管理和控制的.在java程序中栈空间也是类似的,当程序的局部变量中使用基本类型时,它直接在栈上申请了一些空间,而当使用引用来引用对象时,这些
	 * 引用的空间也位于栈上.确切说,在编译阶段,java就可以决定方法的本地变量(LocalVariable)的个数,因此在方法调用的时候,就可以直接分配一个本地变量的区域.
	 * 这个空间是基于slot来分配的,每个slot占用32bit(4个字节),就算是boolean也会占用这么宽,当然long,double会占用2个slot.这些slot可以被复用,也就是说,在方法
	 * 体内部,如果某个局部变量是在循环或判定语句内部声明的,那么在退出这个区域后,对应slot是可以被释放给在它之后声明的局部变量使用的.
	 * 在程序运行过程中,会通过java的虚拟指令(后文中会介绍)来完成对Java虚拟机中的对象和数据做一些操作.虚拟指令只是java的指令,而不是最终指令,有它才会跨平台,它最终
	 * 会在对应OS的虚拟机上被翻译为汇编指令来完成实际硬件的运行操作.
	 * 先使用javap感性认识下虚拟指令是什么,使用javap -verbose来看这个class文件
	 * D:\GitWorkSpace\JavaDemoStudyProject\WebContent\WEB-INF\classes>javap -verbose com.yale.test.run.jvm.ClassInfo
	 * javap结果分为俩个部分,一个是常量池描述信息,一个是字节码的body部分
	 * 常量池描述信息是在编译时就确定的,所谓常量池就是要记录一些常量,这些常量通常包含:类名,方法名,属性名,类型,修饰符,字符串常量,记录他们的入口位置(符号#带上一个数字,可以理解为
	 * 一个入口标志位),一些对象的常量值.初步看,常量池还只是有一些单纯的列表,和程序运行没有多大的关系.在实际运行过程中需要组合成有效的运算指令,.他们在body内部.
	 * iconst_1,将int类型的值1推送到栈顶.
	 * istore_1,将栈顶的元素弹出,赋值给第二个slot的本地变量.这俩个虚拟指令相当于int a =1;
	 * 接下来统一是将int类型的值2推至栈顶,并保存到第3个slot的本地变量中.
	 * iload_1,iload_2是将俩个本地变量的值推至栈顶,然后执行一个iadd操作计算出叠加后的结果放在栈顶,
	 * istore_3将结果数据从栈顶pop出来,保存到第4个slot所对应的本地变量中.这里的"栈顶"是一个后进先出的Stack,可以具体由与CPU交互的操作数组成,但是它并不等价于本地变量.
	 * 它可以进行多个操作后,写回到指定的本地变量中,或者只是用于读操作,就不需要写回到本地变量中了。
	 * iconst相关的指令包括:iconst_m1,iconst_[0-5],对应的虚拟指令的范围是[0x03~0x08],表示[-1~5]之间的数字常量加载到栈顶,如果不是这个范围的数字,就是bipush指令.
	 * istore_1是赋值给slot为起始位置的本地变量,istore_0才是赋值给第一个slot起始位置,那么第0个本地变量是什么呢?是main方法传入的String[]参数,同样的,如果是非静态方法
	 * ,this将作为任何方法的第1个本地变量.
	 * 在LocalVariableTable部分看到几个变量所对应的slot编号也输出了,这里的每个局部变量都单独占用了一个slot,如果局部变量中有double,long类型,slot的个数就会变多.
	 * LocalVariableTable是本地变量列表,某些开发工具(例如Eclipse)默认就有这些信息,通过javac命令编译后的Class文件默认是没有这些输出信息的,换句话说,
	 * 在默认情况下本地变量没有名称的概念。javac -g:vars可以输出相应的信息,如果使用javac -g:vars,lines,则可增加输出LineNumberTable,这个参数将会用于debug(调试)
	 * 中Class与源文件的行号对应关系.如果使用javap -help,则可看到在-g命令后面还可以跟一个source,即javap -g:source其实在默认情况下都是带上参数的,只有使用
	 * javap -g:none时才会什么也不带,但-g:lines是自动带上的,-g:source做了什么呢?通过字节码发现-g:none时常量池中的SourceFile以及文件名不存在了,
	 * 在实际应用中,通过这个类去做断点调试时是做不了的,连断点都没办法打上(测试方法是,编译完的Class打包,然后源文件也打包,在Eclipse中绑定后,可以跟踪到源文件,但是无法给它打断点)
	 * LocalVariableTable列表中每一行代表一个本地变量，每一列的解释如下:
	 * Start,代表本地变量在虚拟指令作用域的起始位置(如第一个本地变量args是从0开始的)
	 * Length,代表本地变量在虚拟指令列表中作用域的长度(如第一个本地变量args是9条指令的作用域)
	 * Slot,代表本地变量的slot起始位置编号(这里是顺序排布的,但是如果出现long,double就会跳跃)
	 * Name,代表本地变量的名称,也就是本地定义的名称.
	 * Signature,代表本地变量的类型(如第1个args是String类型,其他几个都是int类型)
	 * 这些指令是JVM的虚拟指令,它们可能会重排序某些原来的代码顺序(反编译程序也是根据这些指令反转计算回来的,但是反编译程序也会有问题)
	 * 虚拟指令在翻译为CPU的指令运行阶段可能会被再次重排序,也就是运行的顺序可能并不是我们看到的这样.我们只需要知道JVM能发出指令请求,由OS去完成具体工作.
	 * 内存单元有修改(Modified),独占(Exclusive),共享(Shared),失效(Invalid)多种状态
	 */
	public static void main(String[] args) {
		//long num1 = 90L;//long类型变量占了2个slot
		int a = 1;
		int b = 2;
		int c = a + b;
		long num = 90L;
	}
}
